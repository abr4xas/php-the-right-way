---
title:   Errores
isChild: true
anchor:  errores
---

## Errores {#errores_title}

En muchos lenguajes de programación "dependientes de excepciones", cada vez que algo sale mal,
se lanzará una excepción. Esta es una forma viable de manejar errores, pero PHP es un lenguaje "ligero en excepciones".
Aunque tiene excepciones y cada vez más partes del núcleo las usan cuando se trabaja con objetos, la mayoría de PHP
intentará seguir procesando sin importar lo que suceda, a menos que ocurra un error fatal.

Por ejemplo:

{% highlight console %}
$ php -a
php > echo $foo;
Notice: Undefined variable: foo in php shell code on line 1
{% endhighlight %}

Esto es solo un aviso, y PHP continuará felizmente. Esto puede ser confuso para aquellos que vienen de lenguajes
"dependientes de excepciones", porque en Python, por ejemplo, hacer referencia a una variable no definida lanzará una
excepción:

{% highlight console %}
$ python
>>> print foo
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
NameError: name 'foo' is not defined
{% endhighlight %}

La única diferencia real es que Python reaccionará a cualquier pequeño problema, de manera que los desarrolladores
puedan estar muy seguros de que cualquier posible problema o caso límite sea detectado, mientras que PHP seguirá
procesando a menos que suceda algo extremo, en cuyo caso lanzará un error y lo reportará.

### Gravedad de los Errores

PHP tiene varios niveles de gravedad de errores. Los tres tipos más comunes de mensajes son errores, avisos y
advertencias. Estos tienen diferentes niveles de severidad: `E_ERROR`, `E_NOTICE`, y `E_WARNING`.
Los errores son fallos fatales en tiempo de ejecución y usualmente son causados por fallos en tu código que deben ser
corregidos, ya que harán que PHP deje de ejecutarse. Los avisos son mensajes de carácter informativo causados por
código que puede o no causar problemas durante la ejecución del script, pero la ejecución no se detiene.
Las advertencias son errores no fatales, y la ejecución del script no se detendrá.

Otro tipo de mensaje de error reportado en tiempo de compilación son los mensajes `E_STRICT`.
Estos mensajes se utilizan para sugerir cambios en tu código para ayudar a garantizar la mejor interoperabilidad y
compatibilidad con futuras versiones de PHP.

### Cambiar el Comportamiento de Reporte de Errores en PHP

El reporte de errores se puede cambiar utilizando configuraciones de PHP y/o llamadas a funciones de PHP.
Usando la función incorporada `error_reporting()`, puedes establecer el nivel de errores durante la ejecución del script
pasando una de las constantes predefinidas de nivel de error. Por ejemplo, si solo quieres ver Errores y Advertencias,
pero no Avisos (Notices), puedes configurarlo así:

{% highlight php %}
<?php
error_reporting(E_ERROR | E_WARNING);
{% endhighlight %}

También puedes controlar si los errores se muestran en pantalla (útil en desarrollo) o si se ocultan y registran 
(útil en producción). Para más información, revisa la sección de [Reporte de Errores][errorreport].

### Supresión de Errores en Línea

También puedes decirle a PHP que suprima errores específicos usando el Operador de Control de Errores `@`. 
Pones este operador al inicio de una expresión, y cualquier error que sea resultado directo de la expresión se silenciará.

{% highlight php %}
<?php
echo @$foo['bar'];
{% endhighlight %}

Esto imprimirá `$foo['bar']` si existe, pero simplemente devolverá nulo y no mostrará nada si la variable `$foo` o la 
clave `'bar'` no existen. Sin el operador de control de errores, esta expresión podría crear un 
`PHP Notice: Undefined variable: foo` o `PHP Notice: Undefined index: bar`. 

Esto podría parecer una buena idea, pero hay algunas desventajas indeseables. PHP maneja expresiones con un `@` de una 
manera menos eficiente que expresiones sin el `@`. La optimización prematura puede ser la raíz de todas las discusiones 
de programación, pero si el rendimiento es particularmente importante para tu aplicación/biblioteca, es importante 
entender las implicaciones de rendimiento del operador de control de errores.

En segundo lugar, el operador de control de errores suprime **completamente** el error. El error no se muestra y no se
envía al registro de errores. Además, los sistemas PHP estándar/producción no tienen forma de desactivar el operador de 
control de errores. Aunque puede que tengas razón al considerar que el error que estás viendo es inofensivo, un error 
diferente y menos inofensivo será igual de silencioso. 

Si hay una forma de evitar el uso del operador de supresión de errores, deberías considerarla. Por ejemplo, nuestro 
código anterior podría reescribirse de la siguiente manera:

{% highlight php %}
<?php
// Null Coalescing Operator
echo $foo['bar'] ?? '';
{% endhighlight %}

Un caso donde podría tener sentido suprimir un error es cuando `fopen()` falla al encontrar un archivo. Podrías 
verificar la existencia del archivo antes de intentar cargarlo, pero si el archivo se elimina después de la verificación
y antes de la llamada a `fopen()` (lo cual puede parecer imposible, pero puede ocurrir), entonces `fopen()` devolverá
falso _y_ lanzará un error. Esto es algo que PHP debería resolver, pero es un caso donde la supresión de errores podría
parecer la única solución válida.

Mencionamos antes que no hay forma en un sistema PHP estándar de desactivar el operador de control de errores. Sin
embargo, [Xdebug] tiene una configuración `xdebug.scream` en el archivo `ini` que deshabilitará el operador de control
de errores. Puedes configurarlo en tu archivo `php.ini` de la siguiente manera:

{% highlight ini %}
xdebug.scream = On
{% endhighlight %}

También puedes establecer este valor en tiempo de ejecución con la función `ini_set`

{% highlight php %}
<?php
ini_set('xdebug.scream', '1')
{% endhighlight %}

Esto es muy útil cuando estás depurando código y sospechas que un error informativo está siendo suprimido. Usa scream
con cuidado y como una herramienta temporal de depuración. Hay mucho código de bibliotecas PHP que puede no funcionar 
con el operador de control de errores deshabilitado.

* [Operadores de Control de Errores]
* [SitePoint]
* [Xdebug]

### ErrorException

PHP es perfectamente capaz de ser un lenguaje de programación "dependiente de excepciones" y solo requiere unas pocas 
líneas de código para hacer el cambio. Básicamente, puedes lanzar tus "errores" como "excepciones" usando la clase 
`ErrorException`, que extiende la clase `Exception`. 

Esta es una práctica común implementada por un gran número de frameworks modernos como Symfony y Laravel. En modo de 
depuración *(o modo dev)*, ambos frameworks mostrarán una *stack trace* limpia y agradable. 

También hay algunos paquetes disponibles para un mejor manejo y reporte de errores y excepciones, como [Whoops!], 
que viene con la instalación predeterminada de Laravel y puede usarse en cualquier framework. 

Al lanzar errores como excepciones durante el desarrollo, puedes manejarlos mejor que con el resultado habitual, y si 
ves una excepción durante el desarrollo, puedes envolverla en una declaración de captura con instrucciones específicas 
sobre cómo manejar la situación. Cada excepción que captures hace que tu aplicación sea un poco más robusta. 

Más información sobre esto y detalles sobre cómo usar `ErrorException` con el manejo de errores se pueden encontrar en 
la [Clase ErrorException][errorexception].

* [Operadores de Control de Errores]
* [Constantes Predefinidas para el Manejo de Errores]
* [`error_reporting()`][error_reporting]
* [Reporting][errorreport]


[errorreport]: /#error_reporting
[Xdebug]: https://xdebug.org/docs/basic
[Operadores de Control de Errores]: https://www.php.net/language.operators.errorcontrol
[SitePoint]: https://www.sitepoint.com/
[Whoops!]: https://filp.github.io/whoops/
[errorexception]: https://www.php.net/class.errorexception
[Constantes Predefinidas para el Manejo de Errores]: https://www.php.net/errorfunc.constants
[error_reporting]: https://www.php.net/function.error-reporting
